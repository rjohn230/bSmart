/*! @asymmetrik/ngx-leaflet - 3.0.1 - Copyright Asymmetrik, Ltd. 2007-2017 - All Rights Reserved. + */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@angular/core"),require("leaflet")):"function"==typeof define&&define.amd?define(["exports","@angular/core","leaflet"],t):t(e.ngxLeaflet={},e.ng.core,e.L)}(this,function(e,t,r){"use strict";var n=/** @class */function(){function e(e,n){
// Nothing here
this.element=e,this.zone=n,this.DEFAULT_ZOOM=1,this.DEFAULT_CENTER=r.latLng(38.907192,-77.036871),this.DEFAULT_FPZ_OPTIONS={},this.fitBoundsOptions=this.DEFAULT_FPZ_OPTIONS,this.panOptions=this.DEFAULT_FPZ_OPTIONS,this.zoomOptions=this.DEFAULT_FPZ_OPTIONS,this.zoomPanOptions=this.DEFAULT_FPZ_OPTIONS,
// Default configuration
this.options={},
// Configure callback function for the map
this.mapReady=new t.EventEmitter}return e.prototype.ngOnInit=function(){var e=this;
// Create the map with some reasonable defaults
this.zone.runOutsideAngular(function(){e.map=r.map(e.element.nativeElement,e.options)}),
// Only setView if there is a center/zoom
null!=this.center&&null!=this.zoom&&this.setView(this.center,this.zoom)
// Set up all the initial settings
,null!=this.fitBounds&&this.setFitBounds(this.fitBounds),this.doResize(),
// Fire map ready event
this.mapReady.emit(this.map)},e.prototype.ngOnChanges=function(e){
/*
                 * The following code is to address an issue with our (basic) implementation of
                 * zooming and panning. From our testing, it seems that a pan operation followed
                 * by a zoom operation in the same thread will interfere with eachother. The zoom
                 * operation interrupts/cancels the pan, resulting in a final center point that is
                 * inaccurate. The solution seems to be to either separate them with a timeout or
                  * to collapse them into a setView call.
                 */
// Zooming and Panning
e.zoom&&e.center&&null!=this.zoom&&null!=this.center?this.setView(e.center.currentValue,e.zoom.currentValue):e.zoom?this.setZoom(e.zoom.currentValue):e.center&&this.setCenter(e.center.currentValue)
// Fit bounds
,e.fitBounds&&this.setFitBounds(e.fitBounds.currentValue)},e.prototype.getMap=function(){return this.map},e.prototype.onResize=function(){this.delayResize()},
/**
     * Resize the map to fit it's parent container
     */
/**
         * Resize the map to fit it's parent container
         */
e.prototype.doResize=
/**
         * Resize the map to fit it's parent container
         */
function(){var e=this;
// Invalidate the map size to trigger it to update itself
this.zone.runOutsideAngular(function(){e.map.invalidateSize({})})},
/**
     * Manage a delayed resize of the component
     */
/**
         * Manage a delayed resize of the component
         */
e.prototype.delayResize=
/**
         * Manage a delayed resize of the component
         */
function(){null!=this.resizeTimer&&clearTimeout(this.resizeTimer),this.resizeTimer=setTimeout(this.doResize.bind(this),200)},
/**
     * Set the view (center/zoom) all at once
     * @param center The new center
     * @param zoom The new zoom level
     */
/**
         * Set the view (center/zoom) all at once
         * @param center The new center
         * @param zoom The new zoom level
         */
e.prototype.setView=
/**
         * Set the view (center/zoom) all at once
         * @param center The new center
         * @param zoom The new zoom level
         */
function(e,t){var r=this;this.map&&null!=e&&null!=t&&this.zone.runOutsideAngular(function(){r.map.setView(e,t,r.zoomPanOptions)})},
/**
     * Set the map zoom level
     * @param zoom the new zoom level for the map
     */
/**
         * Set the map zoom level
         * @param zoom the new zoom level for the map
         */
e.prototype.setZoom=
/**
         * Set the map zoom level
         * @param zoom the new zoom level for the map
         */
function(e){var t=this;this.map&&null!=e&&this.zone.runOutsideAngular(function(){t.map.setZoom(e,t.zoomOptions)})},
/**
     * Set the center of the map
     * @param center the center point
     */
/**
         * Set the center of the map
         * @param center the center point
         */
e.prototype.setCenter=
/**
         * Set the center of the map
         * @param center the center point
         */
function(e){var t=this;this.map&&null!=e&&this.zone.runOutsideAngular(function(){t.map.panTo(e,t.panOptions)})},
/**
     * Fit the map to the bounds
     * @param center the center point
     */
/**
         * Fit the map to the bounds
         * @param center the center point
         */
e.prototype.setFitBounds=
/**
         * Fit the map to the bounds
         * @param center the center point
         */
function(e){var t=this;this.map&&null!=e&&this.zone.runOutsideAngular(function(){t.map.fitBounds(e,t.fitBoundsOptions)})},e.decorators=[{type:t.Directive,args:[{selector:"[leaflet]"}]}],
/** @nocollapse */
e.ctorParameters=function(){return[{type:t.ElementRef},{type:t.NgZone}]},e.propDecorators={fitBoundsOptions:[{type:t.Input,args:["leafletFitBoundsOptions"]}],panOptions:[{type:t.Input,args:["leafletPanOptions"]}],zoomOptions:[{type:t.Input,args:["leafletZoomOptions"]}],zoomPanOptions:[{type:t.Input,args:["leafletZoomPanOptions"]}],options:[{type:t.Input,args:["leafletOptions"]}],mapReady:[{type:t.Output,args:["leafletMapReady"]}],zoom:[{type:t.Input,args:["leafletZoom"]}],center:[{type:t.Input,args:["leafletCenter"]}],fitBounds:[{type:t.Input,args:["leafletFitBounds"]}],onResize:[{type:t.HostListener,args:["window:resize",[]]}]},e}(),o=/** @class */function(){function e(e){this.leafletDirective=e}return e.prototype.init=function(){
// Nothing for now
},e.prototype.getMap=function(){return this.leafletDirective.getMap()},e}(),i=/** @class */function(){function e(e,t){this.zone=t,this.leafletDirective=new o(e)}return e.prototype.ngOnInit=function(){
// Init the map
this.leafletDirective.init()},e.prototype.ngOnDestroy=function(){var e=this;this.zone.runOutsideAngular(function(){e.layer.remove()})},e.prototype.ngOnChanges=function(e){var t=this;if(e.layer){
// Update the layer
var r=e.layer.previousValue,n=e.layer.currentValue;this.zone.runOutsideAngular(function(){null!=r&&r.remove(),null!=n&&t.leafletDirective.getMap().addLayer(n)})}},e.decorators=[{type:t.Directive,args:[{selector:"[leafletLayer]"}]}],
/** @nocollapse */
e.ctorParameters=function(){return[{type:n},{type:t.NgZone}]},e.propDecorators={layer:[{type:t.Input,args:["leafletLayer"]}]},e}(),s=/** @class */function(){function e(e,t,r){this.differs=t,this.zone=r,this.leafletDirective=new o(e),this.layersDiffer=this.differs.find([]).create()}return Object.defineProperty(e.prototype,"layers",{get:function(){return this.layersValue},set:
// Set/get the layers
function(e){this.layersValue=e,
// Now that we have a differ, do an immediate layer update
this.updateLayers()},enumerable:!0,configurable:!0}),e.prototype.ngDoCheck=function(){this.updateLayers()},e.prototype.ngOnInit=function(){
// Init the map
this.leafletDirective.init(),
// Update layers once the map is ready
this.updateLayers()},e.prototype.ngOnDestroy=function(){this.layers=[]},
/**
     * Update the state of the layers.
     * We use an iterable differ to synchronize the map layers with the state of the bound layers array.
     * This is important because it allows us to react to changes to the contents of the array as well
     * as changes to the actual array instance.
     */
/**
         * Update the state of the layers.
         * We use an iterable differ to synchronize the map layers with the state of the bound layers array.
         * This is important because it allows us to react to changes to the contents of the array as well
         * as changes to the actual array instance.
         */
e.prototype.updateLayers=
/**
         * Update the state of the layers.
         * We use an iterable differ to synchronize the map layers with the state of the bound layers array.
         * This is important because it allows us to react to changes to the contents of the array as well
         * as changes to the actual array instance.
         */
function(){var e=this.leafletDirective.getMap();if(null!=e&&null!=this.layersDiffer){var t=this.layersDiffer.diff(this.layersValue);null!=t&&this.zone.runOutsideAngular(function(){t.forEachRemovedItem(function(t){e.removeLayer(t.item)}),t.forEachAddedItem(function(t){e.addLayer(t.item)})})}},e.decorators=[{type:t.Directive,args:[{selector:"[leafletLayers]"}]}],
/** @nocollapse */
e.ctorParameters=function(){return[{type:n},{type:t.IterableDiffers},{type:t.NgZone}]},e.propDecorators={layers:[{type:t.Input,args:["leafletLayers"]}]},e}(),a=/** @class */function(){function e(){this.layersRemoved=0,this.layersChanged=0,this.layersAdded=0}return e.prototype.changed=function(){return!(0===this.layersRemoved&&0===this.layersChanged&&0===this.layersAdded)},e}(),l=/** @class */function(){function e(e){this.zone=e}return e.prototype.getLayersControl=function(){return this.layersControl},e.prototype.init=function(e,t){var n=this,o=e.baseLayers||{},i=e.overlays||{};return this.zone.runOutsideAngular(function(){n.layersControl=r.control.layers(o,i,t)}),this.layersControl},e.prototype.applyBaseLayerChanges=function(e){var t=new a;return null!=this.layersControl&&(t=this.applyChanges(e,this.layersControl.addBaseLayer)),t},e.prototype.applyOverlayChanges=function(e){var t=new a;return null!=this.layersControl&&(t=this.applyChanges(e,this.layersControl.addOverlay)),t},e.prototype.applyChanges=function(e,t){var r=this,n=new a;return null!=e&&(e.forEachChangedItem(function(e){r.layersControl.removeLayer(e.previousValue),t.call(r.layersControl,e.currentValue,e.key),n.layersChanged++}),e.forEachRemovedItem(function(e){r.layersControl.removeLayer(e.previousValue),n.layersRemoved++}),e.forEachAddedItem(function(e){t.call(r.layersControl,e.currentValue,e.key),n.layersAdded++})),n},e}(),u=/** @class */function(){return function(){this.baseLayers={},this.overlays={}}}(),y=/** @class */function(){function e(e,t,r){this.differs=t,this.zone=r,this.leafletDirective=new o(e),this.controlLayers=new l(r),
// Generate differs
this.baseLayersDiffer=this.differs.find({}).create(),this.overlaysDiffer=this.differs.find({}).create()}return Object.defineProperty(e.prototype,"layersControlConfig",{get:function(){return this.layersControlConfigValue},set:function(e){
// Validation/init stuff
null==e&&(e=new u),null==e.baseLayers&&(e.baseLayers={}),null==e.overlays&&(e.overlays={})
// Store the value
,this.layersControlConfigValue=e,
// Update the map
this.updateLayers()},enumerable:!0,configurable:!0}),e.prototype.ngOnInit=function(){var e=this;
// Init the map
this.leafletDirective.init(),
// Set up all the initial settings
this.zone.runOutsideAngular(function(){e.controlLayers.init({},e.layersControlOptions).addTo(e.leafletDirective.getMap())}),this.updateLayers()},e.prototype.ngOnDestroy=function(){var e=this;this.layersControlConfig={baseLayers:{},overlays:{}},this.zone.runOutsideAngular(function(){e.controlLayers.getLayersControl().remove()})},e.prototype.ngDoCheck=function(){this.updateLayers()},e.prototype.updateLayers=function(){var e=this.leafletDirective.getMap(),t=this.controlLayers.getLayersControl();if(null!=e&&null!=t){
// Run the baselayers differ
if(null!=this.baseLayersDiffer&&null!=this.layersControlConfigValue.baseLayers){var r=this.baseLayersDiffer.diff(this.layersControlConfigValue.baseLayers);this.controlLayers.applyBaseLayerChanges(r)}
// Run the overlays differ
if(null!=this.overlaysDiffer&&null!=this.layersControlConfigValue.overlays){r=this.overlaysDiffer.diff(this.layersControlConfigValue.overlays);this.controlLayers.applyOverlayChanges(r)}}},e.decorators=[{type:t.Directive,args:[{selector:"[leafletLayersControl]"}]}],
/** @nocollapse */
e.ctorParameters=function(){return[{type:n},{type:t.KeyValueDiffers},{type:t.NgZone}]},e.propDecorators={layersControlConfig:[{type:t.Input,args:["leafletLayersControl"]}],layersControlOptions:[{type:t.Input,args:["leafletLayersControlOptions"]}]},e}(),f=/** @class */function(){function e(){}return e.mapToArray=function(e){var t=[];for(var r in e)e.hasOwnProperty(r)&&t.push(e[r]);return t},e}(),p=/** @class */function(){function e(e,t,r){this.differs=t,this.zone=r,this.leafletDirective=new o(e),this.controlLayers=new l(r),this.baseLayersDiffer=this.differs.find({}).create()}return Object.defineProperty(e.prototype,"baseLayers",{get:function(){return this.baseLayersValue},set:
// Set/get baseLayers
function(e){this.baseLayersValue=e,this.updateBaseLayers()},enumerable:!0,configurable:!0}),e.prototype.ngOnDestroy=function(){var e=this;this.baseLayers={},this.zone.runOutsideAngular(function(){e.controlLayers.getLayersControl().remove()})},e.prototype.ngOnInit=function(){var e=this;
// Init the map
this.leafletDirective.init(),
// Initially configure the controlLayers
this.zone.runOutsideAngular(function(){e.controlLayers.init({},e.layersControlOptions).addTo(e.leafletDirective.getMap())}),this.updateBaseLayers()},e.prototype.ngDoCheck=function(){this.updateBaseLayers()},e.prototype.updateBaseLayers=function(){var e=this.leafletDirective.getMap(),t=this.controlLayers.getLayersControl();if(null!=e&&null!=t&&null!=this.baseLayersDiffer){var r=this.baseLayersDiffer.diff(this.baseLayersValue);this.controlLayers.applyBaseLayerChanges(r).changed()&&this.syncBaseLayer()}},
/**
     * Check the current base layer and change it to the new one if necessary
     */
/**
         * Check the current base layer and change it to the new one if necessary
         */
e.prototype.syncBaseLayer=
/**
         * Check the current base layer and change it to the new one if necessary
         */
function(){var e,t=this,r=this.leafletDirective.getMap(),n=f.mapToArray(this.baseLayers);
// Search all the layers in the map to see if we can find them in the baselayer array
r.eachLayer(function(t){e=n.find(function(e){return t===e})}),
// Did we find the layer?
null!=e?
// Yes - set the baselayer to the one we found
this.baseLayer=e:
// No - set the baselayer to the first in the array and add it to the map
n.length>0&&(this.baseLayer=n[0],this.zone.runOutsideAngular(function(){t.baseLayer.addTo(r)}))},e.decorators=[{type:t.Directive,args:[{selector:"[leafletBaseLayers]"}]}],
/** @nocollapse */
e.ctorParameters=function(){return[{type:n},{type:t.KeyValueDiffers},{type:t.NgZone}]},e.propDecorators={baseLayers:[{type:t.Input,args:["leafletBaseLayers"]}],layersControlOptions:[{type:t.Input,args:["leafletLayersControlOptions"]}]},e}(),c=/** @class */function(){function e(){}return e.forRoot=function(){return{ngModule:e,providers:[]}},e.decorators=[{type:t.NgModule,args:[{exports:[n,i,s,y,p],declarations:[n,i,s,y,p]}]}],
/** @nocollapse */
e.ctorParameters=function(){return[]},e}(),h=/** @class */function(){function e(e,t,r){this.type=e,this.url=t,this.options=r}
/**
     * Creates a TileLayer from the provided definition. This is a convenience function
     * to help with generating layers from objects.
     *
     * @param layerDef The layer to create
     * @returns {TileLayer} The TileLayer that has been created
     */
/**
         * Creates a TileLayer from the provided definition. This is a convenience function
         * to help with generating layers from objects.
         *
         * @param layerDef The layer to create
         * @returns {TileLayer} The TileLayer that has been created
         */return e.createTileLayer=
/**
         * Creates a TileLayer from the provided definition. This is a convenience function
         * to help with generating layers from objects.
         *
         * @param layerDef The layer to create
         * @returns {TileLayer} The TileLayer that has been created
         */
function(e){var t;switch(e.type){case"xyz":t=r.tileLayer(e.url,e.options);break;case"wms":default:t=r.tileLayer.wms(e.url,e.options)}return t},
/**
     * Creates a TileLayer for each key in the incoming map. This is a convenience function
     * for generating an associative array of layers from an associative array of objects
     *
     * @param layerDefs A map of key to tile layer definition
     * @returns {{[p: string]: TileLayer}} A new map of key to TileLayer
     */
/**
         * Creates a TileLayer for each key in the incoming map. This is a convenience function
         * for generating an associative array of layers from an associative array of objects
         *
         * @param layerDefs A map of key to tile layer definition
         * @returns {{[p: string]: TileLayer}} A new map of key to TileLayer
         */
e.createTileLayers=
/**
         * Creates a TileLayer for each key in the incoming map. This is a convenience function
         * for generating an associative array of layers from an associative array of objects
         *
         * @param layerDefs A map of key to tile layer definition
         * @returns {{[p: string]: TileLayer}} A new map of key to TileLayer
         */
function(t){var r={};for(var n in t)t.hasOwnProperty(n)&&(r[n]=e.createTileLayer(t[n]));return r},
/**
     * Create a Tile Layer from the current state of this object
     *
     * @returns {TileLayer} A new TileLayer
     */
/**
         * Create a Tile Layer from the current state of this object
         *
         * @returns {TileLayer} A new TileLayer
         */
e.prototype.createTileLayer=
/**
         * Create a Tile Layer from the current state of this object
         *
         * @returns {TileLayer} A new TileLayer
         */
function(){return e.createTileLayer(this)},e}();e.LeafletModule=c,e.LeafletDirective=n,e.LeafletDirectiveWrapper=o,e.LeafletTileLayerDefinition=h,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=ngx-leaflet.js.map