{"version":3,"file":"infinite-list.directive.js","sourceRoot":"","sources":["../../../../../.ng_build/theme/components/list/infinite-list.directive.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Directive,\n  Input,\n  HostListener,\n  ElementRef,\n  EventEmitter,\n  Output,\n  OnDestroy,\n  AfterViewInit,\n  ContentChildren,\n  QueryList,\n} from '@angular/core';\nimport { Observable, forkJoin, of as observableOf, interval, timer } from 'rxjs';\nimport { takeWhile, filter, switchMap, map, takeUntil, take } from 'rxjs/operators';\nimport { convertToBoolProperty } from '../helpers';\nimport { NbLayoutScrollService } from '../../services/scroll.service';\nimport { NbLayoutRulerService } from '../../services/ruler.service';\nimport { NbListItemComponent } from './list.component';\n\nexport class NbScrollableContainerDimentions {\n  scrollTop: number;\n  scrollHeight: number;\n  clientHeight: number;\n}\n\n/**\n * Infinite List Directive\n *\n * ```html\n *  <nb-list nbInfiniteList [threshold]=\"500\" (bottomThreshold)=\"loadNext()\">\n *    <nb-list-item *ngFor=\"let item of items\"></nb-list-item>\n *  </nb-list>\n * ```\n *\n * @stacked-example(Simple infinite list, infinite-list/infinite-list-showcase.component)\n *\n * Directive will notify when list scrolled up or down to given a threshold.\n * By default it listen to scroll of list on which applied, but also can be set to listen to window scroll.\n *\n * @stacked-example(Scroll modes, infinite-list/infinite-list-scroll-modes.component)\n *\n * To improve UX of infinite lists, it's better to keep current page in url,\n * so user able to return to the last viewed page or to share a link to this page.\n * `nbListPageTracker` directive will help you to know, what page user currently viewing.\n * Just put it on a list, set page size and it will calculate page that currently in viewport.\n * You can [open the example](example/infinite-list/infinite-news-list.component)\n * in a new tab to check out this feature.\n *\n * @stacked-example(Infinite list with pager, infinite-list/infinite-news-list.component)\n *\n * @stacked-example(Infinite list with placeholders at the top, infinite-list/infinite-list-placeholders.component)\n *\n */\n@Directive({\n  selector: '[nbInfiniteList]',\n})\nexport class NbInfiniteListDirective implements AfterViewInit, OnDestroy {\n\n  private alive = true;\n  private lastScrollPosition;\n  windowScroll = false;\n  private get elementScroll() {\n    return !this.windowScroll;\n  }\n\n  /**\n   * Threshold after which event load more event will be emited.\n   * In pixels.\n   */\n  @Input()\n  threshold: number;\n\n  /**\n   * By default component observes list scroll position.\n   * If set to `true`, component will observe position of page scroll instead.\n   */\n  @Input()\n  set listenWindowScroll(value) {\n    this.windowScroll = convertToBoolProperty(value);\n  }\n\n  /**\n   * Emits when distance between list bottom and current scroll position is less than threshold.\n   */\n  @Output()\n  bottomThreshold = new EventEmitter(true);\n\n  /**\n   * Emits when distance between list top and current scroll position is less than threshold.\n   */\n  @Output()\n  topThreshold = new EventEmitter(true);\n\n  @HostListener('scroll')\n  onElementScroll() {\n    if (this.elementScroll) {\n      this.checkPosition(this.elementRef.nativeElement);\n    }\n  }\n\n  @ContentChildren(NbListItemComponent) listItems: QueryList<NbListItemComponent>;\n\n  constructor(\n    private elementRef: ElementRef,\n    private scrollService: NbLayoutScrollService,\n    private dimensionsService: NbLayoutRulerService,\n  ) {}\n\n  ngAfterViewInit() {\n    this.scrollService.onScroll()\n      .pipe(\n        takeWhile(() => this.alive),\n        filter(() => this.windowScroll),\n        switchMap(() => this.getContainerDimensions()),\n      )\n      .subscribe(dimentions => this.checkPosition(dimentions));\n\n    this.listItems.changes\n      .pipe(\n        takeWhile(() => this.alive),\n        // For some reason, changes are emitted before list item removed from dom,\n        // so dimensions will be incorrect.\n        // Check every 50ms for a second if dom and query are in sync.\n        // Once they synchronized, we can get proper dimensions.\n        switchMap(() => interval(50).pipe(\n          takeUntil(timer(1000)),\n          filter(() => this.inSyncWithDom()),\n          take(1),\n        )),\n        switchMap(() => this.getContainerDimensions()),\n      )\n      .subscribe(dimentions => this.checkPosition(dimentions));\n\n      this.getContainerDimensions().subscribe(dimentions => this.checkPosition(dimentions));\n  }\n\n  ngOnDestroy() {\n    this.alive = false;\n  }\n\n  checkPosition({ scrollHeight, scrollTop, clientHeight }: NbScrollableContainerDimentions) {\n    const initialCheck = this.lastScrollPosition == null;\n    const manualCheck = this.lastScrollPosition === scrollTop;\n    const scrollUp = scrollTop < this.lastScrollPosition;\n    const scrollDown = scrollTop > this.lastScrollPosition;\n    const distanceToBottom = scrollHeight - scrollTop - clientHeight;\n\n    if ((initialCheck ||  manualCheck || scrollDown) && distanceToBottom <= this.threshold) {\n      this.bottomThreshold.emit();\n    }\n    if ((initialCheck || scrollUp) && scrollTop <= this.threshold) {\n      this.topThreshold.emit();\n    }\n\n    this.lastScrollPosition = scrollTop;\n  }\n\n  private getContainerDimensions(): Observable<NbScrollableContainerDimentions> {\n    if (this.elementScroll) {\n      const { scrollTop, scrollHeight, clientHeight } = this.elementRef.nativeElement;\n      return observableOf({ scrollTop, scrollHeight, clientHeight });\n    }\n\n    return forkJoin(this.scrollService.getPosition(), this.dimensionsService.getDimensions())\n      .pipe(\n          map(([scrollPosition, dimensions]) => ({\n            scrollTop: scrollPosition.y,\n            scrollHeight: dimensions.scrollHeight,\n            clientHeight: dimensions.clientHeight,\n          })),\n      );\n  }\n\n  private inSyncWithDom(): boolean {\n    return this.elementRef.nativeElement.children.length === this.listItems.length;\n  }\n}\n"]}